import{Y as P,ao as d,h as O,q as D,ah as B,t as M,a1 as E,a2 as g,ag as H,ap as R,l as S,a0 as V,aq as z,ar as N}from"./CWRP0EBR.js";const j=a=>a==="defer"||a===!1;function x(...a){var v;const r=typeof a[a.length-1]=="string"?a.pop():void 0;typeof a[0]!="string"&&a.unshift(r);let[e,u,t={}]=a;if(typeof e!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof u!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const s=P(),C=u,w=()=>d.value,b=()=>s.isHydrating?s.payload.data[e]:s.static.data[e];t.server=t.server??!0,t.default=t.default??w,t.getCachedData=t.getCachedData??b,t.lazy=t.lazy??!1,t.immediate=t.immediate??!0,t.deep=t.deep??d.deep,t.dedupe=t.dedupe??"cancel";const f=t.getCachedData(e,s),h=f!=null;if(!s._asyncData[e]||!t.immediate){(v=s.payload._errors)[e]??(v[e]=d.errorValue);const o=t.deep?D:B;s._asyncData[e]={data:o(h?f:t.default()),pending:D(!h),error:M(s.payload._errors,e),status:D("idle"),_default:t.default}}const n={...s._asyncData[e]};delete n._default,n.refresh=n.execute=(o={})=>{if(s._asyncDataPromises[e]){if(j(o.dedupe??t.dedupe))return s._asyncDataPromises[e];s._asyncDataPromises[e].cancelled=!0}if(o._initial||s.isHydrating&&o._initial!==!1){const c=o._initial?f:t.getCachedData(e,s);if(c!=null)return Promise.resolve(c)}n.pending.value=!0,n.status.value="pending";const l=new Promise((c,i)=>{try{c(C(s))}catch(y){i(y)}}).then(async c=>{if(l.cancelled)return s._asyncDataPromises[e];let i=c;t.transform&&(i=await t.transform(c)),t.pick&&(i=K(i,t.pick)),s.payload.data[e]=i,n.data.value=i,n.error.value=d.errorValue,n.status.value="success"}).catch(c=>{if(l.cancelled)return s._asyncDataPromises[e];n.error.value=R(c),n.data.value=S(t.default()),n.status.value="error"}).finally(()=>{l.cancelled||(n.pending.value=!1,delete s._asyncDataPromises[e])});return s._asyncDataPromises[e]=l,s._asyncDataPromises[e]},n.clear=()=>q(s,e);const _=()=>n.refresh({_initial:!0}),m=t.server!==!1&&s.payload.serverRendered;{const o=V();if(o&&m&&t.immediate&&!o.sp&&(o.sp=[]),o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const i=o._nuxtOnBeforeMountCbs;z(()=>{i.forEach(y=>{y()}),i.splice(0,i.length)}),N(()=>i.splice(0,i.length))}m&&s.isHydrating&&(n.error.value||f!=null)?(n.pending.value=!1,n.status.value=n.error.value?"error":"success"):o&&(s.payload.serverRendered&&s.isHydrating||t.lazy)&&t.immediate?o._nuxtOnBeforeMountCbs.push(_):t.immediate&&_();const l=H();if(t.watch){const i=E(t.watch,()=>n.refresh());l&&g(i)}const c=s.hook("app:data:refresh",async i=>{(!i||i.includes(e))&&await n.refresh()});l&&g(c)}const p=Promise.resolve(s._asyncDataPromises[e]).then(()=>n);return Object.assign(p,n),p}function F(a){const r=P();return a in r.payload.data||(r.payload.data[a]=d.value),{data:O({get(){var e;return((e=r._asyncData[a])==null?void 0:e.data.value)??r.payload.data[a]},set(e){r._asyncData[a]?r._asyncData[a].data.value=e:r.payload.data[a]=e}})}}function q(a,r){r in a.payload.data&&(a.payload.data[r]=void 0),r in a.payload._errors&&(a.payload._errors[r]=d.errorValue),a._asyncData[r]&&(a._asyncData[r].data.value=void 0,a._asyncData[r].error.value=d.errorValue,a._asyncData[r].pending.value=!1,a._asyncData[r].status.value="idle"),r in a._asyncDataPromises&&(a._asyncDataPromises[r]&&(a._asyncDataPromises[r].cancelled=!0),a._asyncDataPromises[r]=void 0)}function K(a,r){const e={};for(const u of r)e[u]=a[u];return e}export{x as a,F as u};
